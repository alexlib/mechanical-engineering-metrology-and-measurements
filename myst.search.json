{"version":"1","records":[{"hierarchy":{"lvl1":"The link to the Jupyter book:"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"The link to the Jupyter book:"},"content":"https://​alexlib​.github​.io​/mechanical​-engineering​-metrology​-and​-measurements","type":"content","url":"/","position":1},{"hierarchy":{"lvl1":"The link to the Jupyter book:","lvl2":"Windows command to install uv"},"type":"lvl2","url":"/#windows-command-to-install-uv","position":2},{"hierarchy":{"lvl1":"The link to the Jupyter book:","lvl2":"Windows command to install uv"},"content":"```\npowershell -ExecutionPolicy ByPass -c \"irm https://astral.sh/uv/install.ps1 | iex\"\n```\n\n```\nuv venv\n.venv/Scripts/activate\nuv pip install -r requirements.txt\n```","type":"content","url":"/#windows-command-to-install-uv","position":3},{"hierarchy":{"lvl1":"Analog-to-Digital (A2D) — Introduction and Learning Goals"},"type":"lvl1","url":"/intro-4","position":0},{"hierarchy":{"lvl1":"Analog-to-Digital (A2D) — Introduction and Learning Goals"},"content":"Short summary\nSampling, aliasing, reconstruction, and practical A/D conversion examples.\n\nLearning objectives\n\nExplain sampling theorem and conditions for perfect reconstruction.\n\nDemonstrate aliasing and anti-aliasing requirements.\n\nImplement simple reconstructions (sinc/interpolation) and study errors.\n\nKey concepts (brief)\n\nNyquist frequency and aliasing examples.\n\nReconstruction using sinc (Cardinal series) and practical limits.\n\nQuantization and its effect on measurement uncertainty (intro-level).\n\nRecommended notebooks to run\n\nsampling_aliasing_examples.ipynb\n\nmimic_analog_to_digital_conversion.ipynb\n\nreconstruct_with_sinc.ipynb\n\nReconstruction_periodic_signal_Cardinal_series.ipynb\n\nSuggested exercises\n\nCreate aliased and non-aliased versions of a signal and explain differences.\n\nReconstruct a band-limited signal with truncated sinc and quantify error.\n\nPrerequisites\nBasic Fourier theory and sampling concepts. AUTOGEN_START ","type":"content","url":"/intro-4","position":1},{"hierarchy":{"lvl1":"Analog-to-Digital (A2D) — Introduction and Learning Goals","lvl2":"Pages in this chapter"},"type":"lvl2","url":"/intro-4#pages-in-this-chapter","position":2},{"hierarchy":{"lvl1":"Analog-to-Digital (A2D) — Introduction and Learning Goals","lvl2":"Pages in this chapter"},"content":"Analog to digital (A/D) and Digital to Analog (d/A) conversion example\n\nSignal construction and helper functions for the frequency content class\n\nMimic A/D conversion\n\nDigital to Analog conversion using sinc\n\nSampling, clipping and aliasing AUTOGEN_END ","type":"content","url":"/intro-4#pages-in-this-chapter","position":3},{"hierarchy":{"lvl1":"Calibration — Introduction and Learning Goals"},"type":"lvl1","url":"/intro-2","position":0},{"hierarchy":{"lvl1":"Calibration — Introduction and Learning Goals"},"content":"Short summary\nCalibration methods and error analysis for sensors: linear & nonlinear regression, hysteresis, sensitivity, and full calibration workflow.\n\nLearning objectives\n\nPerform linear regression for sensor calibration and compute confidence intervals.\n\nAnalyze hysteresis and nonlinearity errors.\n\nDesign calibration experiments and propagate calibration uncertainty into measurements.\n\nKey concepts (brief)\n\nRegression residuals, standard error, and calibration curve interpretation.\n\nHysteresis and repeatability characterization.\n\nSensitivity analysis and combining calibration with measurement uncertainty.\n\nRecommended notebooks to run\n\nmicrometer_calibration.ipynb\n\nregression_analysis.ipynb\n\nfull_calibration_analysis_example.ipynb\n\nhysteresis_error_analysis.ipynb\n\ncalibration_non_linear_relations.ipynb\n\nSuggested exercises\n\nCalibrate a sample dataset, report calibration equation and uncertainty.\n\nCompare linear vs nonlinear fits and discuss choice and impact on measurements.\n\nPrerequisites\nBasic regression, statistics, and familiarity with plotting in Python.","type":"content","url":"/intro-2","position":1},{"hierarchy":{"lvl1":"Calibration — Introduction and Learning Goals","lvl3":"Detailed Explanation of the Static Calibration Process"},"type":"lvl3","url":"/intro-2#detailed-explanation-of-the-static-calibration-process","position":2},{"hierarchy":{"lvl1":"Calibration — Introduction and Learning Goals","lvl3":"Detailed Explanation of the Static Calibration Process"},"content":"Static calibration is a procedure used to characterize a measurement system by applying a known, constant input value to the system and observing the resulting output value.\n\nThe term “static” refers to the fact that the variables are held constant, meaning the input is not dependent on time.","type":"content","url":"/intro-2#detailed-explanation-of-the-static-calibration-process","position":3},{"hierarchy":{"lvl1":"Calibration — Introduction and Learning Goals","lvl4":"1. Purpose","lvl3":"Detailed Explanation of the Static Calibration Process"},"type":"lvl4","url":"/intro-2#id-1-purpose","position":4},{"hierarchy":{"lvl1":"Calibration — Introduction and Learning Goals","lvl4":"1. Purpose","lvl3":"Detailed Explanation of the Static Calibration Process"},"content":"The primary purpose of static calibration is twofold:\n\nFunctional Relationship: To develop a functional relationship, or a correlation (y = f(x)), between the system’s known input (x) and its output (y). This correlation is often determined using curve fitting techniques, such as regression analysis, on the calibration curve.\n\nSystematic Error Identification: To identify and quantify systematic errors (biases) such as zero error, linearity error, and hysteresis.","type":"content","url":"/intro-2#id-1-purpose","position":5},{"hierarchy":{"lvl1":"Calibration — Introduction and Learning Goals","lvl4":"2. Procedure Steps","lvl3":"Detailed Explanation of the Static Calibration Process"},"type":"lvl4","url":"/intro-2#id-2-procedure-steps","position":6},{"hierarchy":{"lvl1":"Calibration — Introduction and Learning Goals","lvl4":"2. Procedure Steps","lvl3":"Detailed Explanation of the Static Calibration Process"},"content":"To perform a static calibration, you generate a calibration curve by recording the output values (y_i) for a range of known input values (x_i).\n\nReference Standard: A standard (known value) that is traceable to national standards must be used. This reference instrument should have significantly lower uncertainty than the instrument being tested.\n\nControlled Points: The chamber or environment is set to a series of stable, discrete input points across the operational range.\n\nHysteresis Check: Measurements should be taken by varying the input value in both the increasing (upscale) and decreasing (downscale) directions to assess hysteresis.\n\nData Collection: At each stable point, the system is allowed to reach thermal equilibrium, and multiple readings are taken to assess repeatability.\n\nData Analysis: The data is plotted to create the calibration curve. This curve is used to determine key parameters like static sensitivity (the slope of the curve), and to quantify errors like linearity and hysteresis.","type":"content","url":"/intro-2#id-2-procedure-steps","position":7},{"hierarchy":{"lvl1":"Calibration — Introduction and Learning Goals","lvl3":"Error Analysis and Uncertainty Categorization"},"type":"lvl3","url":"/intro-2#error-analysis-and-uncertainty-categorization","position":8},{"hierarchy":{"lvl1":"Calibration — Introduction and Learning Goals","lvl3":"Error Analysis and Uncertainty Categorization"},"content":"In metrology, an error is the quantifiable difference between an estimate and the “true value,” which can sometimes be corrected. Uncertainty is the quantification of the doubt about that measurement result.\n\nSystematic errors found during calibration, such as zero offset, can sometimes be corrected by adjustment. If the error cannot be corrected (e.g., hysteresis, remaining linearity deviation), the quantified range of that potential error must be included in the uncertainty budget as a Type B contribution.\n\nThe table below outlines common error types, how they are determined, and their subsequent role in uncertainty analysis:\n\nError Type\n\nDescription & Measurement Method\n\nSystematic Error Correction?\n\nUncertainty Type/Source\n\nRepeatability Error (u_{rep})\n\nThe variability or scatter found when the same input is applied repeatedly. Accounts for random variations. Measured: Calculated as the standard deviation (S_x) from repeated readings taken during the static calibration procedure.\n\nNo. This is a source of random error.\n\nType A. Calculated as the standard deviation of the mean (S_x / \\sqrt{n}).\n\nStatic Sensitivity (K)\n\nThe slope of the calibration curve at any given point. Measured: Defined as K(x_1) = (dy/dx)_{x=x_1}.\n\nUsed to define the functional relationship for converting output (y) back to input (x).\n\nType B (The Sensitivity Error (u_K) is a statistical measure of random error in the estimate of the slope).\n\nZero Error (u_z)\n\nA vertical shift or offset from the true zero point of the instrument. Measured: Determined by checking the output when a zero input condition is applied.\n\nYes. If possible, the error is reduced by physically adjusting the output under a zero input condition.\n\nType B (The remaining, uncorrected zero uncertainty, often related to resolution).\n\nLinearity Error (u_L)\n\nThe deviation of the calibration curve from an expected straight line. Measured: Calculated as the maximum deviation between the actual output y(x) and the best-fit linear output y_L(x).\n\nIf the deviation is large, the correction may involve using a higher-order polynomial fit, which models the error.\n\nType B (If a linear fit is required, the linearity error bounds define a semi-range limit for a Type B rectangular distribution).\n\nHysteresis Error (u_h)\n\nThe maximum difference in output value when the input is approached from increasing versus decreasing directions. Caused by friction or residual charge. Measured: Calculated as the maximum difference between upscale and downscale readings at the same input point across the full range.\n\nNo. Typically quantified, but not corrected. It is a systematic bias that must be factored into the uncertainty estimate.\n\nType B (The maximum hysteresis error defines the limit for a Type B uncertainty estimate, often expressed as a percentage of the full-scale output range).\n\nOverall Instrument Error (u_c)\n\nThe total quantified uncertainty of the instrument due to known effects (e.g., combining u_h, u_L, u_K). Measured: Combined using the Root-Sum-Squared (RSS) method: u_c = \\sqrt{u_h^2 + u_L^2 + u_K^2 + \\dots}.\n\nIf the calibration shows a consistent offset or non-linearity, a correction can be applied to future readings.\n\nCombined Standard Uncertainty (u_c).\n\nDoes this detailed breakdown of the static calibration process and the associated errors clarify how systematic errors lead to Type B uncertainty contributions? If so, we can move on to discussing dynamic calibration or perhaps delve into how to apply sensitivity coefficients, which are often necessary after calibration! AUTOGEN_START ","type":"content","url":"/intro-2#error-analysis-and-uncertainty-categorization","position":9},{"hierarchy":{"lvl1":"Calibration — Introduction and Learning Goals","lvl2":"Pages in this chapter"},"type":"lvl2","url":"/intro-2#pages-in-this-chapter","position":10},{"hierarchy":{"lvl1":"Calibration — Introduction and Learning Goals","lvl2":"Pages in this chapter"},"content":"Linearity error example\n\nCalibration of non-linear (logarithmic) function\n\n[Hysteresis example](calibration_error_analysis 2.ipynb)\n\nHysteresis and regression analysis example\n\nCalibration of non-linear relations\n\nCalibration and uncertainty analysis - virtual experiment\n\n## Hysteresis and log-log calibration example\n\n## Introduction to linear regression\n\n## LVDT example\n\nMicrometer calibration using gage block\n\nCalibration and uncertainty analysis - virtual experiment\n\nLecture 6\n\nSensitivity estimate example\n\nLVDT calibration example AUTOGEN_END ","type":"content","url":"/intro-2#pages-in-this-chapter","position":11},{"hierarchy":{"lvl1":"Example of Weighing Scale Calibration Analysis"},"type":"lvl1","url":"/weight-scale-example-wheeler","position":0},{"hierarchy":{"lvl1":"Example of Weighing Scale Calibration Analysis"},"content":"","type":"content","url":"/weight-scale-example-wheeler","position":1},{"hierarchy":{"lvl1":"Example of Weighing Scale Calibration Analysis"},"type":"lvl1","url":"/weight-scale-example-wheeler#example-of-weighing-scale-calibration-analysis","position":2},{"hierarchy":{"lvl1":"Example of Weighing Scale Calibration Analysis"},"content":"This document meticulously recreates the analysis of a weighing scale calibration as presented in “Chapter 2: General Characteristics of Measurement Systems.” \n\nWheeler & Ganji (2009)\n\nWe will extract the data from the provided tables, use Python to perform the calculations, and generate the figures to validate the error estimates described in the text. The analysis covers the determination of accuracy, linearity, hysteresis, repeatability, and systematic errors.\n\n# First, we import the necessary Python libraries for data manipulation, numerical operations, and plotting.\n\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n","type":"content","url":"/weight-scale-example-wheeler#example-of-weighing-scale-calibration-analysis","position":3},{"hierarchy":{"lvl1":"Data Extraction and Preparation"},"type":"lvl1","url":"/weight-scale-example-wheeler#data-extraction-and-preparation","position":4},{"hierarchy":{"lvl1":"Data Extraction and Preparation"},"content":"The calibration process involves applying weights from 0 to 5 lbs (up data) and then removing them (down data) over five complete cycles. The raw measurements are provided in Table E2.3(a). We begin by structuring this data into a pandas DataFrame, which is a tabular data structure, to facilitate analysis.\n\nThe top half of the table represents the “up data” (increasing weight), and the bottom half represents the “down data” (decreasing weight).","type":"content","url":"/weight-scale-example-wheeler#data-extraction-and-preparation","position":5},{"hierarchy":{"lvl1":"Data Extraction and Preparation","lvl2":"TABLE E2.3(a) Scale Calibration Data"},"type":"lvl2","url":"/weight-scale-example-wheeler#table-e2-3-a-scale-calibration-data","position":6},{"hierarchy":{"lvl1":"Data Extraction and Preparation","lvl2":"TABLE E2.3(a) Scale Calibration Data"},"content":"True weight (lb)\n\nCycle 1\n\nCycle 2\n\nCycle 3\n\nCycle 4\n\nCycle 5\n\nCycle 6\n\n0.5\n\n\n\n0.2\n\n0.08\n\n0.17\n\n0.19\n\n0.11\n\n1\n\n\n\n0.7\n\n0.78\n\n0.64\n\n0.61\n\n0.7\n\n1.5\n\n\n\n1.18\n\n1.26\n\n1.25\n\n1.24\n\n1.23\n\n2\n\n\n\n1.81\n\n1.93\n\n1.81\n\n1.93\n\n1.88\n\n2.5\n\n2.62\n\n2.49\n\n2.46\n\n2.46\n\n2.58\n\n2.53\n\n3\n\n3.15\n\n3.18\n\n3.24\n\n3.28\n\n3.13\n\n\n\n3.5\n\n3.9\n\n3.84\n\n3.86\n\n3.97\n\n3.96\n\n\n\n4\n\n4.59\n\n4.71\n\n4.61\n\n4.6\n\n4.6\n\n\n\n4.5\n\n5.41\n\n5.35\n\n5.49\n\n5.46\n\n5.39\n\n\n\n5\n\n6.24\n\n6.27\n\n6.1\n\n6.24\n\n6.16\n\n\n\n4.5\n\n5.71\n\n5.74\n\n5.78\n\n5.87\n\n5.82\n\n\n\n4\n\n4.96\n\n5.11\n\n5.08\n\n5.03\n\n5.03\n\n\n\n3.5\n\n4.22\n\n4.34\n\n4.21\n\n4.22\n\n4.24\n\n\n\n3\n\n3.57\n\n3.64\n\n3.66\n\n3.55\n\n3.67\n\n\n\n2.5\n\n2.98\n\n2.86\n\n2.98\n\n2.98\n\n2.94\n\n\n\n2\n\n2.22\n\n2.23\n\n2.26\n\n2.29\n\n2.26\n\n\n\n1.5\n\n1.57\n\n1.7\n\n1.69\n\n1.63\n\n1.57\n\n\n\n1\n\n1.07\n\n1.07\n\n1.11\n\n1.16\n\n1.11\n\n\n\n0.5\n\n0.52\n\n0.61\n\n0.61\n\n0.61\n\n0.45\n\n\n\n0\n\n0.02\n\n0.08\n\n0.08\n\n-0.03\n\n0.06\n\n\n\n# The provided text and table has some slight inconsistencies. \n# For example, cycle 1 is incomplete. For cycle 6 in the table, it only shows the 'up' data.\n# For simplicity and to match the text's analysis, we will create the dataframe based on the logic of 5 full cycles.\n# The data provided in the prompt seems to be missing some data points, so we will use the data from the tables.\n# Data is re-constructed from Table E2.3(a)\nimport numpy as np\n\ncycles_data = {\n    'True_Weight': [0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 4.5, 4.0, 3.5, 3.0, 2.5, 2.0, 1.5, 1.0, 0.5, 0.0],\n    'Cycle_1': [np.nan, np.nan, np.nan, np.nan, 2.62, 3.15, 3.9, 4.59, 5.41, 6.24, 5.71, 4.96, 4.22, 3.57, 2.98, 2.22, 1.57, 1.07, 0.52, 0.02],\n    'Cycle_2': [0.2, 0.7, 1.18, 1.81, 2.49, 3.18, 3.84, 4.71, 5.35, 6.27, 5.74, 5.11, 4.34, 3.64, 2.86, 2.23, 1.7, 1.07, 0.61, 0.08],\n    'Cycle_3': [0.08, 0.78, 1.26, 1.93, 2.46, 3.24, 3.86, 4.61, 5.49, 6.1, 5.78, 5.08, 4.21, 3.66, 2.98, 2.26, 1.69, 1.11, 0.61, 0.08],\n    'Cycle_4': [0.17, 0.64, 1.25, 1.81, 2.46, 3.28, 3.97, 4.6, 5.46, 6.24, 5.87, 5.03, 4.22, 3.55, 2.98, 2.29, 1.63, 1.16, 0.61, -0.03],\n    'Cycle_5': [0.19, 0.61, 1.24, 1.93, 2.58, 3.13, 3.96, 4.6, 5.39, 6.16, 5.82, 5.03, 4.24, 3.67, 2.94, 2.26, 1.57, 1.11, 0.45, 0.06]\n}\ndf_raw = pd.DataFrame(cycles_data)\n\n# Melt the DataFrame to long format\ndf = df_raw.melt(id_vars=['True_Weight'], var_name='Cycle', value_name='Scale_Reading')\n# df['Cycle'] = df['Cycle'].str.extract('(\\d+)').astype(int)\n\n# Add direction\ndf['Direction'] = np.where(df.index % 20 < 10, 'Up', 'Down')\ndf = df.dropna().sort_values(by=['Cycle', 'Direction', 'True_Weight']).reset_index(drop=True)\n\nprint(df)\n\n","type":"content","url":"/weight-scale-example-wheeler#table-e2-3-a-scale-calibration-data","position":7},{"hierarchy":{"lvl1":"Recreating the Analysis"},"type":"lvl1","url":"/weight-scale-example-wheeler#recreating-the-analysis","position":8},{"hierarchy":{"lvl1":"Recreating the Analysis"},"content":"With the data prepared, we can now proceed with the analysis.","type":"content","url":"/weight-scale-example-wheeler#recreating-the-analysis","position":9},{"hierarchy":{"lvl1":"Recreating the Analysis","lvl2":"The “Best Fit” Line and Deviation Calculation"},"type":"lvl2","url":"/weight-scale-example-wheeler#the-best-fit-line-and-deviation-calculation","position":10},{"hierarchy":{"lvl1":"Recreating the Analysis","lvl2":"The “Best Fit” Line and Deviation Calculation"},"content":"The text provides a linear equation, derived by “eyeballing” a line through the data, to correlate the scale reading (R) with the true weight (W):\nR = 1.290W - 0.374\n\nWe will use this equation to calculate the predicted reading for each true weight. The deviation is the difference between the actual Scale_Reading and this predicted value. A positive deviation means the scale read higher than the model predicted.\n\ndef best_fit_line(W):\n    return 1.290 * W - 0.374\n\ndf['Predicted_Reading'] = best_fit_line(df['True_Weight'])\ndf['Deviation'] = df['Scale_Reading'] - df['Predicted_Reading']\n\n","type":"content","url":"/weight-scale-example-wheeler#the-best-fit-line-and-deviation-calculation","position":11},{"hierarchy":{"lvl1":"Recreating the Analysis","lvl2":"Figure E2.3(b): Plot of Scale Readings"},"type":"lvl2","url":"/weight-scale-example-wheeler#figure-e2-3-b-plot-of-scale-readings","position":12},{"hierarchy":{"lvl1":"Recreating the Analysis","lvl2":"Figure E2.3(b): Plot of Scale Readings"},"content":"This plot shows the raw scale readings against the true weight. The two distinct bands of data are clearly visible, representing the “up” and “down” measurement cycles. This separation is caused by hysteresis. The best-fit line is plotted through the data.\n\nplt.figure(figsize=(8, 6))\nplt.scatter(df['True_Weight'], df['Scale_Reading'], marker='x', color='black', label='Measured Data')\nW_range = np.linspace(0, 5, 100)\nR_fit = best_fit_line(W_range)\nplt.plot(W_range, R_fit, 'k--', label='Best fit line (R = 1.290W - 0.374)')\nplt.xlabel('True weight (lb)')\nplt.ylabel('Scale reading (lb)')\nplt.title('Figure E2.3(b): Plot of Scale Readings')\nplt.grid(True)\nplt.legend()\nplt.show()\n\n\n","type":"content","url":"/weight-scale-example-wheeler#figure-e2-3-b-plot-of-scale-readings","position":13},{"hierarchy":{"lvl1":"Recreating the Analysis","lvl2":"Figure E2.3(c): Plot of Deviation Data"},"type":"lvl2","url":"/weight-scale-example-wheeler#figure-e2-3-c-plot-of-deviation-data","position":14},{"hierarchy":{"lvl1":"Recreating the Analysis","lvl2":"Figure E2.3(c): Plot of Deviation Data"},"content":"This plot is crucial for error evaluation. It shows the deviation of each measurement from the best-fit line. This visualization makes it easier to determine the bounds of the error.\n\n\nplt.figure(figsize=(8, 6))\nplt.scatter(df['True_Weight'], df['Deviation'], marker='x', color='black')\nplt.axhline(0, color='black', linewidth=0.8)\n\n# Accuracy limits from the text\nplt.axhline(0.45, color='blue', linestyle='--', label='Accuracy Limit (+0.45 lb)')\nplt.axhline(-0.40, color='magenta', linestyle='--', label='Accuracy Limit (-0.40 lb)')\n\nplt.xlabel('True weight (lb)')\nplt.ylabel('Deviation (lb)')\nplt.title('Figure E2.3(c): Plot of Deviation Data for Scale Calibration')\nplt.ylim(-0.6, 0.6)\nplt.legend()\nplt.grid(True)\nplt.show()\n\n\n","type":"content","url":"/weight-scale-example-wheeler#figure-e2-3-c-plot-of-deviation-data","position":15},{"hierarchy":{"lvl1":"Estimation of Errors"},"type":"lvl1","url":"/weight-scale-example-wheeler#estimation-of-errors","position":16},{"hierarchy":{"lvl1":"Estimation of Errors"},"content":"From the deviation data, we can now quantify the different types of static calibration errors.","type":"content","url":"/weight-scale-example-wheeler#estimation-of-errors","position":17},{"hierarchy":{"lvl1":"Estimation of Errors","lvl2":"Accuracy"},"type":"lvl2","url":"/weight-scale-example-wheeler#accuracy","position":18},{"hierarchy":{"lvl1":"Estimation of Errors","lvl2":"Accuracy"},"content":"Accuracy is a bounding error statement. It is determined by the maximum positive and negative deviations observed across all measurements.\n\n\nmax_deviation = df['Deviation'].max()\nmin_deviation = df['Deviation'].min()\n\n# Output span calculation\noutput_min = best_fit_line(0)\noutput_max = best_fit_line(5)\noutput_span = output_max - output_min\n\naccuracy_pos_percent = (max_deviation / output_span) * 100\naccuracy_neg_percent = (min_deviation / output_span) * 100\n\nprint(f\"Maximum Deviation (Accuracy Limit): +{max_deviation:.2f} lb\")\nprint(f\"Minimum Deviation (Accuracy Limit): {min_deviation:.2f} lb\")\nprint(f\"Output Span: {output_span:.2f} lb\")\nprint(f\"Accuracy as a percentage of span: +{accuracy_pos_percent:.1f}% / {accuracy_neg_percent:.1f}%\")\n\n\nThe calculated values of +0.45 lb and -0.40 lb match the accuracy limits stated in the text.","type":"content","url":"/weight-scale-example-wheeler#accuracy","position":19},{"hierarchy":{"lvl1":"Estimation of Errors","lvl2":"Hysteresis Error"},"type":"lvl2","url":"/weight-scale-example-wheeler#hysteresis-error","position":20},{"hierarchy":{"lvl1":"Estimation of Errors","lvl2":"Hysteresis Error"},"content":"Hysteresis is the maximum difference between the “up” and “down” readings for the same true weight within any single cycle.\n\n\nhysteresis_values = []\nfor cycle in df['Cycle'].unique():\n    cycle_df = df[df['Cycle'] == cycle]\n    # Pivot to get up and down readings side-by-side\n    pivoted = cycle_df.pivot_table(index='True_Weight', columns='Direction', values='Scale_Reading')\n    # Calculate difference where both up and down data exist\n    pivoted['Difference'] = pivoted['Down'] - pivoted['Up']\n    if not pivoted['Difference'].dropna().empty:\n        max_hysteresis_in_cycle = pivoted['Difference'].max()\n        hysteresis_values.append(max_hysteresis_in_cycle)\n\nmax_hysteresis = max(hysteresis_values)\nhysteresis_percent_span = (max_hysteresis / output_span) * 100\n\nprint(f\"Maximum Hysteresis Error: {max_hysteresis:.2f} lb\")\nprint(f\"Hysteresis as a percentage of span: {hysteresis_percent_span:.1f}%\")\n\n\nThis result of 0.52 lb matches the value in the text, which is described as a combination of hysteresis and dead band error.","type":"content","url":"/weight-scale-example-wheeler#hysteresis-error","position":21},{"hierarchy":{"lvl1":"Estimation of Errors","lvl2":"Repeatability Error"},"type":"lvl2","url":"/weight-scale-example-wheeler#repeatability-error","position":22},{"hierarchy":{"lvl1":"Estimation of Errors","lvl2":"Repeatability Error"},"content":"Repeatability is the maximum variation in readings for the same input when approached from the same direction. We calculate the range (max - min) of readings for each true weight and direction across all cycles.\n\n\nrepeatability_df = df.groupby(['True_Weight', 'Direction'])['Scale_Reading'].agg(lambda x: x.max() - x.min()).reset_index()\nmax_repeatability_error = repeatability_df['Scale_Reading'].max()\n\n# The text mentions +/- 1.3%, so the full range is 2.6%\nrepeatability_percent_span = (max_repeatability_error / output_span) * 100\n\nprint(f\"Maximum Repeatability Error (Variation): {max_repeatability_error:.2f} lb\")\nprint(f\"This corresponds to {repeatability_percent_span:.1f}% of the output span.\")\nprint(f\"As an error band, this is +/- {repeatability_percent_span/2:.1f}% of the output span.\")\n\n\nThe maximum variation of 0.17 lb corresponds to the value mentioned in the text.","type":"content","url":"/weight-scale-example-wheeler#repeatability-error","position":23},{"hierarchy":{"lvl1":"Estimation of Errors","lvl2":"Systematic Error"},"type":"lvl2","url":"/weight-scale-example-wheeler#systematic-error","position":24},{"hierarchy":{"lvl1":"Estimation of Errors","lvl2":"Systematic Error"},"content":"Systematic error is estimated by averaging the readings for each measurement condition (true weight and direction) and finding the maximum deviations of these averages.\n\navg_deviations = df.groupby(['True_Weight', 'Direction'])['Deviation'].mean()\nmax_systematic_error = avg_deviations.max()\nmin_systematic_error = avg_deviations.min()\n\nsystematic_pos_percent = (max_systematic_error / output_span) * 100\nsystematic_neg_percent = (min_systematic_error / output_span) * 100\n\nprint(f\"Maximum Systematic Error Limit: +{max_systematic_error:.2f} lb (+{systematic_pos_percent:.1f}%)\")\nprint(f\"Minimum Systematic Error Limit: {min_systematic_error:.2f} lb ({systematic_neg_percent:.1f}%)\")\n\n\nThese results (+0.41 lb and -0.35 lb) are consistent with the estimates provided in the text.","type":"content","url":"/weight-scale-example-wheeler#systematic-error","position":25},{"hierarchy":{"lvl1":"Estimation of Errors","lvl2":"Figure E2.3(d): Average Deviation Data Plot"},"type":"lvl2","url":"/weight-scale-example-wheeler#figure-e2-3-d-average-deviation-data-plot","position":26},{"hierarchy":{"lvl1":"Estimation of Errors","lvl2":"Figure E2.3(d): Average Deviation Data Plot"},"content":"This final plot visualizes the systematic error and nonlinearity. It plots the average deviation for “up” readings, “down” readings, and the average of both.\n\n# Calculate averages for the plot\navg_up_dev = df[df['Direction'] == 'Up'].groupby('True_Weight')['Deviation'].mean()\navg_down_dev = df[df['Direction'] == 'Down'].groupby('True_Weight')['Deviation'].mean()\navg_up_down_dev = df.groupby('True_Weight')['Deviation'].mean()\n\nplt.figure(figsize=(8, 6))\nplt.plot(avg_down_dev.index, avg_down_dev.values, 's', markerfacecolor='none', markeredgecolor='black', label='Average of down readings')\nplt.plot(avg_up_dev.index, avg_up_dev.values, 's', markerfacecolor='white', markeredgecolor='black', label='Average of up readings')\nplt.plot(avg_up_down_dev.index, avg_up_down_dev.values, 'o', color='black', label='Average of up-down readings')\n\nplt.axhline(0, color='black', linewidth=0.8)\nplt.xlabel('True weight (lb)')\nplt.ylabel('Average deviation (lb)')\nplt.title('Figure E2.3(d): Average Deviation Data for Scale Calibration')\nplt.grid(True)\nplt.legend()\nplt.show()\n\n","type":"content","url":"/weight-scale-example-wheeler#figure-e2-3-d-average-deviation-data-plot","position":27},{"hierarchy":{"lvl1":"Conclusion"},"type":"lvl1","url":"/weight-scale-example-wheeler#conclusion","position":28},{"hierarchy":{"lvl1":"Conclusion"},"content":"This document has successfully replicated the calibration analysis of the weighing scale. By programmatically processing the raw data, we have verified the values for accuracy, hysteresis, repeatability, and systematic error presented in the original text. The generated figures visually match those in the example, confirming our understanding and implementation of the static calibration procedures. This exercise demonstrates how a comprehensive error analysis can be conducted on a measurement system.","type":"content","url":"/weight-scale-example-wheeler#conclusion","position":29},{"hierarchy":{"lvl1":"Dynamic Signals — Introduction and Learning Goals"},"type":"lvl1","url":"/intro-6","position":0},{"hierarchy":{"lvl1":"Dynamic Signals — Introduction and Learning Goals"},"content":"Short summary\nTime-domain and dynamical-system behavior: step responses, first/second order systems, and vibration-based measurements.\n\nLearning objectives\n\nInterpret first- and second-order system responses and key parameters (time constant, damping, natural frequency).\n\nExtract physical quantities (e.g., mass from vibrations) from measured signals.\n\nLink time-domain responses to frequency content.\n\nKey concepts (brief)\n\nStep response, log-decrement, and damping ratio estimation.\n\nModal interpretation for simple systems and measurement-driven parameter estimation.\n\nPractical considerations: sensor dynamics and filtering.\n\nRecommended notebooks to run\n\nfirst_order_time_response.ipynb\n\nstep_response.ipynb\n\n2nd_order_system_step_function_log_decrement.ipynb\n\nmass_measurement_using_vibrations.ipynb\n\ndesign_choice_2nd_order_pressure_transducer.ipynb\n\nSuggested exercises\n\nEstimate time constant and uncertainty from a noisy step response.\n\nUse a recorded vibration signal to estimate a lumped mass or natural frequency.\n\nPrerequisites\nOrdinary differential equations basics and elementary signal processing. AUTOGEN_START ","type":"content","url":"/intro-6","position":1},{"hierarchy":{"lvl1":"Dynamic Signals — Introduction and Learning Goals","lvl2":"Pages in this chapter"},"type":"lvl2","url":"/intro-6#pages-in-this-chapter","position":2},{"hierarchy":{"lvl1":"Dynamic Signals — Introduction and Learning Goals","lvl2":"Pages in this chapter"},"content":"Log decrement method\n\nExample of pre-measurement design\n\n1st order dynamic system\n\nPlot power spectrum of experimental data\n\nLab Worksheet: Measurement of Unknown Mass using Vibrating Beam\n\nFast Fourier Transform (FFT) of a sum of two sine signals\n\nSpectrum example\n\nStep responses of dynamical systems\n\nSymbolic evaluation of Fourier series coefficients AUTOGEN_END ","type":"content","url":"/intro-6#pages-in-this-chapter","position":3},{"hierarchy":{"lvl1":"Mechanical Engineering Metrology and Measurements (MEMM)"},"type":"lvl1","url":"/intro","position":0},{"hierarchy":{"lvl1":"Mechanical Engineering Metrology and Measurements (MEMM)"},"content":"Set of Jupyter notebooks, prepared by \n\nProf. Alex Liberzon, School of Mechanical Engineering, Faculty of Engineering, Tel Aviv University for the course that is called in many places as “Mechanical Measurements Lab 1” or “Theory and Design of Mechanical Measurements”, “Introduction to Measurements for Mechanical Engineers”, etc. This is a small sample book to give you a feel for how book content is\nstructured.\nIt shows off a few of the major file types and some sample content.\nIt does not discuss any particular topic in depth—for more information, check out [the Jupyter Book documentation](https://jupyterbook.org).\n \n\nThis book does not replace the course materials but rather organizes them in Jupyter and Markdown notebooks. We hope it is useful as an assistance learning material for undergraduate engineering laboratory courses. It is an open-source project, and any contribution is welcome ( contact on \n\nGithub ).","type":"content","url":"/intro","position":1},{"hierarchy":{"lvl1":"Mechanical Engineering Metrology and Measurements (MEMM)","lvl3":"Textbook and relevant books:"},"type":"lvl3","url":"/intro#textbook-and-relevant-books","position":2},{"hierarchy":{"lvl1":"Mechanical Engineering Metrology and Measurements (MEMM)","lvl3":"Textbook and relevant books:"},"content":"This course follows the \n\nFigliola & Beasley (2020). It is also recommended to consult with \n\nDunn & Davis (2017) and \n\nWheeler & Ganji (2009)","type":"content","url":"/intro#textbook-and-relevant-books","position":3},{"hierarchy":{"lvl1":"Mechanical Engineering Metrology and Measurements (MEMM)","lvl2":"Metrology & Measurements — Course Introduction"},"type":"lvl2","url":"/intro#metrology-measurements-course-introduction","position":4},{"hierarchy":{"lvl1":"Mechanical Engineering Metrology and Measurements (MEMM)","lvl2":"Metrology & Measurements — Course Introduction"},"content":"This book collects practical notebooks and concise explanations to teach core concepts in mechanical engineering metrology and measurements. Content emphasizes hands-on examples, reproducible analyses, and problem-solving skills appropriate for undergraduate laboratory and lecture use.","type":"content","url":"/intro#metrology-measurements-course-introduction","position":5},{"hierarchy":{"lvl1":"Mechanical Engineering Metrology and Measurements (MEMM)","lvl3":"Learning objectives","lvl2":"Metrology & Measurements — Course Introduction"},"type":"lvl3","url":"/intro#learning-objectives","position":6},{"hierarchy":{"lvl1":"Mechanical Engineering Metrology and Measurements (MEMM)","lvl3":"Learning objectives","lvl2":"Metrology & Measurements — Course Introduction"},"content":"By the end of this course/readings, students will be able to:\n\nExplain fundamental measurement concepts: accuracy, precision, resolution, and uncertainty.\n\nApply statistical tools to analyze measurement data (distributions, confidence intervals, t‑tests, outlier detection).\n\nPerform calibration and regression analysis for common sensors and instruments.\n\nAnalyze dynamic signals using time‑domain and frequency‑domain methods (FFT, windowing, spectral interpretation).\n\nUnderstand sampling, aliasing, and basic reconstruction for A/D systems.\n\nModel simple measurement systems (first and second order) and interpret step/impulse responses.\n\nPropagate measurement uncertainty (analytical and Monte Carlo) and report results following good practice.\n\nImplement reproducible experiments and analyses using Python and Jupyter notebooks.","type":"content","url":"/intro#learning-objectives","position":7},{"hierarchy":{"lvl1":"Mechanical Engineering Metrology and Measurements (MEMM)","lvl3":"Recommended prerequisites","lvl2":"Metrology & Measurements — Course Introduction"},"type":"lvl3","url":"/intro#recommended-prerequisites","position":8},{"hierarchy":{"lvl1":"Mechanical Engineering Metrology and Measurements (MEMM)","lvl3":"Recommended prerequisites","lvl2":"Metrology & Measurements — Course Introduction"},"content":"Students should be comfortable with:\n\nCalculus and basic differential equations\n\nLinear algebra (vectors, matrices)\n\nIntroductory probability and statistics\n\nBasics of signals and systems (sinusoids, frequency, convolution helpful but not required)\n\nBasic Python programming (variables, functions, NumPy arrays)\n\nFamiliarity with Jupyter notebooks and command-line usage is helpful","type":"content","url":"/intro#recommended-prerequisites","position":9},{"hierarchy":{"lvl1":"Mechanical Engineering Metrology and Measurements (MEMM)","lvl3":"How to use this book","lvl2":"Metrology & Measurements — Course Introduction"},"type":"lvl3","url":"/intro#how-to-use-this-book","position":10},{"hierarchy":{"lvl1":"Mechanical Engineering Metrology and Measurements (MEMM)","lvl3":"How to use this book","lvl2":"Metrology & Measurements — Course Introduction"},"content":"Navigate chapters via the table of contents. Each chapter contains short explanatory pages and runnable notebooks for labs and examples.\n\nDo the notebooks interactively: create a local virtual environment, install requirements, and run the notebooks in Jupyter Lab/Notebook.\n\nWork through the “unsorted” and “archive” content only after core topics; many items are homework examples or experimental notes.\n\nInstructors: adopt notebooks as lab exercises, add assessment items, and redistribute with solutions for guided learning.","type":"content","url":"/intro#how-to-use-this-book","position":11},{"hierarchy":{"lvl1":"Mechanical Engineering Metrology and Measurements (MEMM)","lvl3":"Quick environment notes","lvl2":"Metrology & Measurements — Course Introduction"},"type":"lvl3","url":"/intro#quick-environment-notes","position":12},{"hierarchy":{"lvl1":"Mechanical Engineering Metrology and Measurements (MEMM)","lvl3":"Quick environment notes","lvl2":"Metrology & Measurements — Course Introduction"},"content":"Recommended Python ecosystem: Python 3.9+, NumPy, SciPy, Matplotlib, pandas, jupyter-book, myst-nb. Add a pinned requirements.txt in the repo root for reproducible builds.\n\nStart with the “theory”, “statistics”, and “a2d” chapters, then proceed to “signal_processing”, “dynamic_signals”, and “calibration” for lab work and examples.","type":"content","url":"/intro#quick-environment-notes","position":13},{"hierarchy":{"lvl1":"Mechanical Engineering Metrology and Measurements (MEMM)","lvl3":"Table of contents","lvl2":"Metrology & Measurements — Course Introduction"},"type":"lvl3","url":"/intro#table-of-contents","position":14},{"hierarchy":{"lvl1":"Mechanical Engineering Metrology and Measurements (MEMM)","lvl3":"Table of contents","lvl2":"Metrology & Measurements — Course Introduction"},"content":"The link to the Jupyter book:\n\nMechanical Engineering Metrology and Measurements (MEMM)\n\nTheory — Introduction and Learning Goals\n\nCalibration — Introduction and Learning Goals\n\nExample of Weighing Scale Calibration Analysis\n\nStatistics — Introduction and Learning Goals\n\nAnalog-to-Digital (A2D) — Introduction and Learning Goals\n\nSignal Processing — Introduction and Learning Goals\n\nDynamic Signals — Introduction and Learning Goals","type":"content","url":"/intro#table-of-contents","position":15},{"hierarchy":{"lvl1":"Mechanical Engineering Metrology and Measurements (MEMM)","lvl3":"Copyright Information","lvl2":"Metrology & Measurements — Course Introduction"},"type":"lvl3","url":"/intro#copyright-information","position":16},{"hierarchy":{"lvl1":"Mechanical Engineering Metrology and Measurements (MEMM)","lvl3":"Copyright Information","lvl2":"Metrology & Measurements — Course Introduction"},"content":"\n\nTo the extent possible under law, \n\nthe person who associated CC0 with this work has waived all copyright and related or neighboring rights to this work. \n## References\n```{bibliography}\n``` ","type":"content","url":"/intro#copyright-information","position":17},{"hierarchy":{"lvl1":"Signal Processing — Introduction and Learning Goals"},"type":"lvl1","url":"/intro-5","position":0},{"hierarchy":{"lvl1":"Signal Processing — Introduction and Learning Goals"},"content":"Short summary\nFrequency-domain tools for measurement signals: FFT, windowing, spectral interpretation, and basic filtering.\n\nLearning objectives\n\nCompute and interpret discrete Fourier transforms and spectra.\n\nUnderstand windowing, spectral leakage, and resolution trade-offs.\n\nApply simple spectral filtering and reconstruction concepts.\n\nKey concepts (brief)\n\nFrequency resolution, Nyquist limit, and window-induced spectral effects.\n\nInterpreting power spectra vs amplitude spectra.\n\nPractical filtering: time-domain vs frequency-domain considerations.\n\nRecommended notebooks to run\n\nsimple_fft_two_sine.ipynb\n\nspectrum_example.ipynb\n\nFFT_based_filtering.ipynb\n\nFourier_transform_with_windowing.ipynb\n\nFrequency_content_of_a_periodic_signal.ipynb\n\nSuggested exercises\n\nDemonstrate aliasing by downsampling and explain observed artifacts.\n\nCompare window functions on a mixed-frequency signal and discuss leakage.\n\nPrerequisites\nDiscrete signals, sampling basics, and NumPy FFT usage. AUTOGEN_START ","type":"content","url":"/intro-5","position":1},{"hierarchy":{"lvl1":"Signal Processing — Introduction and Learning Goals","lvl2":"Pages in this chapter"},"type":"lvl2","url":"/intro-5#pages-in-this-chapter","position":2},{"hierarchy":{"lvl1":"Signal Processing — Introduction and Learning Goals","lvl2":"Pages in this chapter"},"content":"Using FFT-based filter to reduce noise\n\nSymbolic evaluation of Fourier coefficients\n\nFourier transforms with windowing\n\nFourier transforms\n\nUsing FFT the right way to find the correct spectrum\n\n## FFT demo of a real, periodic signal\n\nDigitizing the signal using pure Python AUTOGEN_END ","type":"content","url":"/intro-5#pages-in-this-chapter","position":3},{"hierarchy":{"lvl1":"Statistics — Introduction and Learning Goals"},"type":"lvl1","url":"/intro-3","position":0},{"hierarchy":{"lvl1":"Statistics — Introduction and Learning Goals"},"content":"Short summary\nHands-on statistics for measurement data: distributions, descriptive stats, hypothesis testing, outliers, and the central limit theorem.\n\nLearning objectives\n\nCompute and interpret mean, variance, confidence intervals.\n\nApply t-tests, chi-square tests, and identify outliers.\n\nRelate histograms to probability distributions and sampling variability (CLT).\n\nKey concepts (brief)\n\nSampling distributions and the Central Limit Theorem.\n\nWhen to use t-distribution vs normal approximation.\n\nRobust statistics and practical outlier handling.\n\nRecommended notebooks to run\n\nbasic_statistics.ipynb\n\ndistributions.ipynb\n\nt-test.ipynb\n\nCentral_limit_theorem_illustration.ipynb\n\noutliers_example.ipynb and outliers_example_pairs.ipynb\n\nSuggested exercises\n\nUse bootstrap or t-test to compare two small-sample datasets.\n\nDetect and justify removal/retention of outliers in a measurement series.\n\nPrerequisites\nIntroductory probability and basic Python (NumPy, matplotlib). AUTOGEN_START ","type":"content","url":"/intro-3","position":1},{"hierarchy":{"lvl1":"Statistics — Introduction and Learning Goals","lvl2":"Pages in this chapter"},"type":"lvl2","url":"/intro-3#pages-in-this-chapter","position":2},{"hierarchy":{"lvl1":"Statistics — Introduction and Learning Goals","lvl2":"Pages in this chapter"},"content":"Central limit theorem (or why errors often look Gaussian)\n\nStatistical distribution\n\n## Lecture 5 - probability and statistics\n\nVery basic review of some statistics terms\n\nStatistics example\n\nProbability Distributions and the Central Limit Theorem\n\nStatistical parameters using probability density function\n\nhistogram​_to​_distribution\n\nOutliers\n\nOutliers\n\nOutliers example 2\n\nOutliers\n\n“Student” t-distribution\n\nt-test AUTOGEN_END ","type":"content","url":"/intro-3#pages-in-this-chapter","position":3},{"hierarchy":{"lvl1":"Theory — Introduction and Learning Goals"},"type":"lvl1","url":"/intro-1","position":0},{"hierarchy":{"lvl1":"Theory — Introduction and Learning Goals"},"content":"Short summary\nThis chapter covers measurement theory: uncertainty concepts, best practices, measurement-system analysis, and worked Monte Carlo examples.\n\nLearning objectives\n\nUnderstand types of measurement uncertainty and how to report them.\n\nDistinguish repeatability vs reproducibility, bias, and systematic errors.\n\nApply basic uncertainty propagation (analytical and Monte Carlo).\n\nRecognize good-practice recommendations for lab notebooks and reporting.\n\nKey concepts (brief)\n\nGUM-style uncertainty vs Type A/B estimates.\n\nPropagation of uncertainty for slopes and model parameters.\n\nRole of simulations (Monte Carlo) to validate analytical propagation.\n\nRecommended notebooks to run\n\nuncertainty_example.ipynb\n\nuncertainty_of_a_slope.ipynb\n\nuncertainty_propagation_monte_carlo_gum.ipynb\n\nteaching_measurement_uncertainty.ipynb\n\nbest_practice_summary.ipynb\n\nSuggested exercises\n\nCompute and compare analytical and Monte Carlo propagation on a simple function.\n\nPrepare a short lab report following the best-practice notebook checklist.\n\nPrerequisites\nBasic probability, calculus, and comfort with Python arrays.","type":"content","url":"/intro-1","position":1},{"hierarchy":{"lvl1":"Theory — Introduction and Learning Goals","lvl3":"Checklist for the 8-step uncertainty analysis process"},"type":"lvl3","url":"/intro-1#checklist-for-the-8-step-uncertainty-analysis-process","position":2},{"hierarchy":{"lvl1":"Theory — Introduction and Learning Goals","lvl3":"Checklist for the 8-step uncertainty analysis process"},"content":"See \n\nchecklist.md for a detailed 9-step checklist to guide uncertainty analyses. AUTOGEN_START ","type":"content","url":"/intro-1#checklist-for-the-8-step-uncertainty-analysis-process","position":3},{"hierarchy":{"lvl1":"Theory — Introduction and Learning Goals","lvl2":"Pages in this chapter"},"type":"lvl2","url":"/intro-1#pages-in-this-chapter","position":4},{"hierarchy":{"lvl1":"Theory — Introduction and Learning Goals","lvl2":"Pages in this chapter"},"content":"Sensitivity Coefficients in Uncertainty Budgets\n\nShort summary of the ``Measurement good practice guide ‘’ by NPL\n\nMars Rover Temperature Measurement & Uncertainty Analysis\n\nUsing AI tools to learn uncertainty\n\nEngineering Example: Uncertainty Analysis in Mechanical Measurements\n\nGeneral measurement system\n\nUncertainty in simple terms from IAEA\n\nLaboratory Notebook\n\nSignificant digits\n\nSimple example of mechanical measurement with uncertainty analysis\n\nUsing simulations to explain uncertainty\n\nStandardization\n\nTeaching Measurement in the Introductory Physics Laboratory\n\nTeaching uncertainty in mechanical measurements\n\nUncertainty 101\n\nUncertainty Analysis\n\nuncertainty_example\n\nHow to estimate the uncertainty of a slope for static calibration or regression\n\nPropagating uncertainty using Monte-Carlo simulations AUTOGEN_END ","type":"content","url":"/intro-1#pages-in-this-chapter","position":5},{"hierarchy":{"lvl1":"Theory — Introduction and Learning Goals","lvl2":"Ordered reading (suggested)"},"type":"lvl2","url":"/intro-1#ordered-reading-suggested","position":6},{"hierarchy":{"lvl1":"Theory — Introduction and Learning Goals","lvl2":"Ordered reading (suggested)"},"content":"Follow this sequence when teaching or self-studying. The order moves from foundational lab practice and best-practice guidance, to measurement-system analysis and elementary worked examples, then to uncertainty concepts and quantitative propagation methods (analytical & Monte Carlo), and finishes with advanced case studies and community presentations.\n\nlaboratory​_notebook​.ipynb — practical lab notebook practices and data recording.\n\nbest​_practice​_summary​.ipynb — concise recommendations for reporting and reproducibility.\n\nteaching​_measurement​_uncertainty​.ipynb — pedagogical overview of uncertainty.\n\nstandartization​.ipynb — standards and common terminology.\n\ngeneral​_measurement​_system​_analysis​.ipynb — system-level thinking and error sources.\n\nsimple​_example​.ipynb — a short worked example linking practice and theory.\n\nexample​_from​_best​_practice​.ipynb — illustrated application of best practices.\n\nuncertainty​_example​.ipynb — basic uncertainty calculations and interpretation.\n\nuncertainty​_of​_a​_slope​.ipynb — propagation for regression-derived quantities.\n\nuncertainty​_propagation​_monte​_carlo​_gum​.ipynb — Monte Carlo propagation following GUM ideas.\n\nsimulations​_for​_uncertainty​.ipynb — simulation-driven exploration of uncertainty.\n\nuncertainty​_analysis​_NASA​.ipynb — applied example from NASA guidance.\n\niaea​_uncertainty​_presentation​.ipynb — community presentation and advanced perspectives.\n\nWatch the 1 hr video by Fluke - leading measurement equipment company\n\nRationale: this ordering lets students first acquire good lab habits and reporting skills, then build a conceptual toolbox for system analysis, then learn measurement uncertainty in increasing rigor (examples → slope propagation → Monte Carlo → case studies). Use the checklists added to notebooks to guide in-class or lab activities.","type":"content","url":"/intro-1#ordered-reading-suggested","position":7}]}